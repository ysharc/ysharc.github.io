<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Deep Learning Fundamentals - Neuron and the Perceptron Algorithm</title>
      <link href="/2018/03/28/Getting-started-with-Deep-Learning/"/>
      <url>/2018/03/28/Getting-started-with-Deep-Learning/</url>
      <content type="html"><![CDATA[<p>This is the first part of the series <em>“Deep Learning Fundamentals”</em>. The goal of this series is to explore the mechanisms of artificial neural networks. The focus is more on presenting an intuitive way of understanding neural networks. So, you can expect an emphasis on how and why things work rather than what does the job. More often than not I’ll try to use simple math without focusing on notation. Let’s jump into the fundamental unit of most of the neural networks - “a neuron”.<br><a id="more"></a></p><h2 id="Neuron"><a href="#Neuron" class="headerlink" title="Neuron"></a>Neuron</h2><p>A neuron is nothing but a binary classifier. Which means given an n-dimensional space, it can divide the space into two regions. Let’s try to come up with an algorithm that does this, given that the data is linearly separable. For the sake of brevity, let’s consider that the data we deal with is numerical across all dimensions. (Dealing with other kinds of data is for another post.)</p><p>Without loss of generality let’s start working with two-dimensional data. So, let’s say there are some green(0) and blue(1) points on a plane and we want a line that separates these points. An intuitive way would be to draw a line like shown in the graph below. So far so good. But what we need finally is an algorithm that does this for us all this by itself and adjusts to any new points.<br><iframe src="https://www.desmos.com/calculator/smmkhlshap?embed" width="100%" height="300px" frameborder="0" allowfullscreen></iframe></p><h2 id="The-Search-for-a-Classifier"><a href="#The-Search-for-a-Classifier" class="headerlink" title="The Search for a Classifier"></a>The Search for a Classifier</h2><p>Let’s start with a random line in this space and then see what we must do, for creating the two regions. Let’s try it ourselves first. One way would be to rotate and translate the line until it separates the two regions. This seems intuitive enough. Play around with the interactive graph below to separate the two groups of points.</p><p>You would’ve noticed that $a$ and $b$ contribute to the rotation and $c$ contributes to translation. This makes sense because $a$ and $b$ control the slope and $c$ controls the distance from the origin. But how did you know when to stop fiddling around with those parameters? A trivial but useful answer would be to stop when there are no misclassified points.</p><p>At this point, we are good to develop a general algorithm for classifying two groups of points. We would do something like this</p><pre><code>Initialize random line parameterswhile misclassified points are present:    fiddle around with the line parameters</code></pre><h2 id="The-perceptron-trick"><a href="#The-perceptron-trick" class="headerlink" title="The perceptron trick"></a>The perceptron trick</h2><p>Let’s start making the algorithm a little more concrete. Let the line be <strong>$ax_1 + bx_2 + c = 0$</strong>, where we initialize <strong>$a$</strong>, <strong>$b$</strong>, <strong>$c$</strong> at random. For classifying the points, let’s first give the points some labels(0 and 1) to differentiate them. Let $P(x_1, x_2)$ be a point in our data space with a label <strong>$L_P$</strong>. If <strong>$(ax_1+ bx_2 + c &gt; 0) = L_P$</strong> then <strong>$P$</strong>‘s classification is correct.</p><p>Now let’s deal with the fiddling part of the algorithm. Before we see any math on this let’s try to build our intuition for it. Below are two cases where <strong>$0$</strong> label point and a <strong>$1$</strong> label point are misclassified. See if you can come up with a general rule for modifying <strong>$a$</strong>, <strong>$b$</strong> and <strong>$c$</strong> that leads to the correct classification.</p><iframe src="https://www.desmos.com/calculator/hjsqj15ufk" width="100%" height="600px" frameborder="0" allowfullscreen></iframe><p>With a bit of effort, you can observe that the following pattern works for any situation</p><ul><li>increase parameters for a point labeled <strong>$1$</strong> and classified as <strong>$0$</strong>.</li><li>decrease parameters for a point labeled <strong>$0$</strong> and classified as <strong>$1$</strong>.</li></ul><p>If you have found out this pattern then Don’t worry if you haven’t found this out. Try it now and see if it works. The reason you might have missed the pattern is that you were trying to</p><ul><li>increase one parameter and decrease another.</li><li>increase or decrease the parameters by a random amount until it does the job.</li></ul><p>There’s nothing wrong with the above two operations because you’re trying to get the job done. But the problem is that we can’t generalize those operations for any given scenario. So, by this point, you should have a decent amount of intuition on how all this works. So, here’s how you can update the parameters. The amount by which they have to be updated is directly proportional to <strong>$x_1$</strong> for <strong>$a$</strong>, <strong>$x_2$</strong> for <strong>$b$</strong>. This translates to the following formula which works for both kinds of misclassification.</p><blockquote><p>For every misclassified point <strong>$P(x_1, x_2)$</strong>:</p><blockquote><p><strong>$a = a + \alpha (expected - predicted) x_1$</strong><br><strong>$b = b + \alpha (expected - predicted) x_2$</strong><br><strong>$c = c + \alpha (expected - predicted)$</strong></p></blockquote></blockquote><p>Here <strong>$\alpha$</strong> is the proportionality constant and is like a fine-tuning knob. It controls the rate at which we change these parameters, also known as the <em>“learning rate”</em>. We need our perceptron to change the parameters in a slow manner. Because large changes often tend to misclassify points that were correctly classified before. There aren’t any fixed good values for the learning rate. See for yourself how learning rate affects the speed and performance <a href="https://www.cs.utexas.edu/~teammco/misc/perceptron/" target="_blank" rel="noopener">here</a>.</p><p>In a Deep Learning setting the parameters $a$, $b$ are usually denoted by $w_1$, $w_2$ and are part of a vector $w$. $c$ is known as bias. The inputs and outputs of a neuron are as shown in the figure below.</p><p><img src="https://www.dropbox.com/s/j6vksnlibf0yhgq/perceptron.png?raw=1" alt="Perceptron"></p><h2 id="The-Perceptron-Algorithm"><a href="#The-Perceptron-Algorithm" class="headerlink" title="The Perceptron Algorithm"></a>The Perceptron Algorithm</h2><p>To wrap up this section, here’s the formal definition in a deep learning setting.</p><p><strong>Data</strong>: Training Data:<strong>$(x_i , y_i )$</strong>; <strong>$\forall i \in {0, 1, 2, . . . , N }$</strong>, Learning Rate: <strong>$\eta$</strong>, where</p><ul><li>$x_i$ is a m-dimensional input vector and $N$ is the total number of instances of our data.</li><li>$x_{i, 0} = 1;$ $\forall i \in {0, 1, 2, . . . , N }$</li></ul><p><strong>Result</strong>: Separating Hyper-plane coefficients :<strong>$w^∗$</strong><br><strong>Initialize</strong> <strong>$w$</strong> ← random weights ; (Since $x_{i, 0} = 1, w_0$ acts as the bias without setting it seperately.)<br><strong>repeat</strong></p><blockquote><p>get example <strong>$(x_i , y_i )$</strong>;<br><strong>$\hat y_i ← w^T x_i $</strong>;<br><strong>$w ← w + \eta(y_i − {\hat y}_i )x_i$</strong></p></blockquote><p><strong>until</strong> convergence;</p><p>Here’s your dopamine shot for making it till the end.</p><p><img src="https://imgs.xkcd.com/comics/machine_learning.png" alt="XKCD comic"></p>]]></content>
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Fundamentals </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Portfolio</title>
      <link href="/portfolio/index.html"/>
      <url>/portfolio/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/resources/index.html"/>
      <url>/resources/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Topics</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
